{
  "tasks": [
    {
      "id": 1,
      "title": "Setup iOS Project with SwiftUI and Core Architecture",
      "description": "Initialize the iOS project with SwiftUI, implement MVVM architecture, and set up the basic project structure including data models and local storage with SwiftData.",
      "details": "1. Create a new iOS project using SwiftUI\n2. Set up MVVM architecture with folders for Models, Views, ViewModels\n3. Implement core data models:\n   - SermonRecording (id, title, audioURL, serviceType, date, duration)\n   - Note (id, content, timestamp, sermonId)\n   - Transcription (id, content, sermonId)\n   - UserProfile (id, email, tier, usage)\n   - ServiceType (enum: Sunday, BibleStudy, Midweek, Conference, GuestSpeaker)\n4. Configure SwiftData for local storage\n5. Set up basic navigation structure with TabView\n6. Implement offline-first approach with local caching\n7. Create reusable UI components\n\nCode example for SermonRecording model:\n```swift\n@Model\nclass SermonRecording {\n    var id: UUID\n    var title: String\n    var audioURL: URL?\n    var serviceType: ServiceType\n    var date: Date\n    var duration: TimeInterval\n    var notes: [Note]?\n    var transcription: Transcription?\n    \n    init(id: UUID = UUID(), title: String, serviceType: ServiceType, date: Date = Date()) {\n        self.id = id\n        self.title = title\n        self.serviceType = serviceType\n        self.date = date\n        self.duration = 0\n    }\n}\n```",
      "testStrategy": "1. Unit tests for all data models to ensure proper initialization and relationships\n2. UI tests for basic navigation flow\n3. Test offline capabilities by toggling network connection\n4. Verify SwiftData persistence by creating and retrieving objects\n5. Test app performance metrics including launch time (target: under 2 seconds)\n6. Verify proper MVVM separation by testing ViewModels independently",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Audio Recording and Service Type Selection",
      "description": "Create the audio recording functionality with AVFoundation, implement the record button UI, service type selection modal, and recording status indicators.",
      "details": "1. Implement AVFoundation integration for audio recording\n2. Configure audio settings: AAC format, 128kbps, 44.1kHz\n3. Create RecordingManager class to handle recording state and file management\n4. Design and implement the central record button in tab bar\n5. Create service type selection modal that appears after tapping record\n6. Implement visual recording indicators (animated waveform or timer)\n7. Handle permissions for microphone access\n8. Implement offline recording capability with local storage\n9. Add higher quality recording option (256kbps) for paid tier users\n\nCode example for RecordingManager:\n```swift\nclass RecordingManager: ObservableObject {\n    @Published var isRecording = false\n    @Published var currentRecording: SermonRecording?\n    private var audioRecorder: AVAudioRecorder?\n    \n    func startRecording(serviceType: ServiceType) {\n        let audioSession = AVAudioSession.sharedInstance()\n        \n        do {\n            try audioSession.setCategory(.playAndRecord, mode: .default)\n            try audioSession.setActive(true)\n            \n            let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n            let audioFilename = documentsPath.appendingPathComponent(\"\\(UUID().uuidString).m4a\")\n            \n            let settings = [\n                AVFormatIDKey: Int(kAudioFormatMPEG4AAC),\n                AVSampleRateKey: 44100.0,\n                AVNumberOfChannelsKey: 1,\n                AVEncoderBitRateKey: 128000\n            ] as [String: Any]\n            \n            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)\n            audioRecorder?.record()\n            \n            isRecording = true\n            currentRecording = SermonRecording(title: \"New Recording\", serviceType: serviceType)\n            currentRecording?.audioURL = audioFilename\n        } catch {\n            print(\"Recording failed: \\(error)\")\n        }\n    }\n    \n    func stopRecording() {\n        audioRecorder?.stop()\n        isRecording = false\n        // Save recording to SwiftData\n    }\n}\n```",
      "testStrategy": "1. Test microphone permission handling\n2. Verify audio recording quality and format\n3. Test service type selection modal UI and functionality\n4. Verify recording indicators update correctly\n5. Test offline recording and subsequent upload\n6. Measure battery impact during extended recording sessions\n7. Verify different quality settings for free vs paid users\n8. Test error handling for recording failures",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create RecordingManager Class with AVFoundation Integration",
          "description": "Implement the RecordingManager class that will handle audio recording functionality using AVFoundation, including the core methods for starting and stopping recordings.",
          "dependencies": [],
          "details": "1. Create a new RecordingManager class as an ObservableObject\n2. Add properties for tracking recording state and current recording\n3. Implement AVAudioRecorder integration\n4. Create methods for starting recording with proper audio settings (AAC format, 128kbps, 44.1kHz)\n5. Implement stopRecording method\n6. Add error handling for recording failures",
          "status": "done",
          "testStrategy": "Test the RecordingManager by creating a simple UI that triggers recording start/stop and verifies that audio files are created in the documents directory."
        },
        {
          "id": 2,
          "title": "Implement Microphone Permission Handling",
          "description": "Add functionality to request and handle microphone access permissions, ensuring the app properly requests access before attempting to record.",
          "dependencies": [
            1
          ],
          "details": "1. Update Info.plist with microphone usage description\n2. Create a PermissionManager class or extend RecordingManager to check microphone permission status\n3. Implement method to request microphone permissions\n4. Add proper error handling and user feedback for denied permissions\n5. Ensure recording only starts after permissions are granted",
          "status": "done",
          "testStrategy": "Test permission flows by running on device and verifying permission dialogs appear correctly. Test denial scenarios to ensure appropriate error messages are shown."
        },
        {
          "id": 3,
          "title": "Design and Implement Record Button in Tab Bar",
          "description": "Create the UI for the central record button in the tab bar that will trigger the recording flow.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Design a circular record button with appropriate styling\n2. Position the button in the center of the tab bar\n3. Add tap gesture recognition\n4. Implement visual feedback for button press\n5. Connect button tap to show the service type selection modal\n6. Update button appearance based on recording state (normal vs. recording)",
          "status": "done",
          "testStrategy": "Test the button's visual appearance in different states and verify that tapping it correctly triggers the service type selection modal."
        },
        {
          "id": 4,
          "title": "Create Service Type Selection Modal",
          "description": "Implement the modal dialog that appears after tapping the record button, allowing users to select the type of service they are recording.",
          "dependencies": [
            3
          ],
          "details": "1. Create a new SwiftUI view for the service type selection modal\n2. Design a list or grid of service type options (Sunday Service, Bible Study, etc.)\n3. Implement selection behavior with visual feedback\n4. Add a confirmation button to start recording\n5. Connect selection to the RecordingManager to start recording with the selected service type\n6. Include option to cancel without starting recording",
          "status": "done",
          "testStrategy": "Test that all service types can be selected, that the modal appears and dismisses correctly, and that selecting a service type properly initiates recording."
        },
        {
          "id": 5,
          "title": "Implement Recording Status Indicators",
          "description": "Add visual indicators to show recording status, including an animated waveform or timer to provide feedback during active recording.",
          "dependencies": [
            1,
            4
          ],
          "details": "1. Create a RecordingStatusView component\n2. Implement a timer display showing elapsed recording time\n3. Add a simple animated waveform visualization (can be simplified in initial implementation)\n4. Connect the view to RecordingManager's isRecording state\n5. Add a stop recording button\n6. Ensure the status indicators are visible when recording is active",
          "status": "done",
          "testStrategy": "Test that the recording indicators appear correctly when recording starts, that the timer increments properly, and that the stop button successfully ends the recording session."
        }
      ]
    },
    {
      "id": 3,
      "title": "Develop Real-time Note-taking Interface",
      "description": "Create the dual-pane note-taking interface that allows users to type notes while recording is in progress, with continuous auto-save functionality, timestamping, and rich note actions.",
      "status": "in-progress",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "1. Implement dual-pane UI with:\n   - Top pane: Live audio waveform with timer and basic controls\n   - Bottom pane: Note-taking area (fully editable)\n2. Implement TextEditor with styling for note input\n3. Create auto-save functionality that persists notes as user types\n4. Implement note association with current recording session\n5. Add keyboard handling and text formatting options\n6. Create NotesViewModel to manage note state and persistence\n7. Implement offline support for notes\n8. Add timestamping functionality that marks notes when Enter is pressed or after a short pause\n9. Implement rich note actions:\n   - Highlighting text with color (saving timestamp)\n   - Bookmarking important moments in the recording\n   - Scripture tagging with quick entry box\n10. Create enhanced data structure for notes including timestamp, text content, tags, and scripture references\n11. Add floating action buttons (FABs) near the note panel for quick access to features\n\nCode example for NotesView:\n```swift\nstruct NotesView: View {\n    @ObservedObject var viewModel: NotesViewModel\n    @EnvironmentObject var recordingManager: RecordingManager\n    \n    var body: some View {\n        VStack(spacing: 0) {\n            // Top pane: Recording status with waveform and controls\n            if recordingManager.isRecording {\n                RecordingStatusView(duration: viewModel.elapsedTime)\n                    .frame(height: 100)\n                    .background(Color.red.opacity(0.1))\n            }\n            \n            // Bottom pane: Note taking area\n            ZStack(alignment: .bottomTrailing) {\n                TextEditor(text: $viewModel.noteText)\n                    .padding()\n                    .onChange(of: viewModel.noteText) { newValue in\n                        viewModel.checkForTimestamp(newText: newValue)\n                        viewModel.saveNote()\n                    }\n                    .toolbar {\n                        ToolbarItemGroup(placement: .keyboard) {\n                            // Text formatting buttons\n                            Button(action: { viewModel.formatBold() }) {\n                                Image(systemName: \"bold\")\n                            }\n                            Button(action: { viewModel.formatItalic() }) {\n                                Image(systemName: \"italic\")\n                            }\n                            Button(action: { viewModel.addHighlight() }) {\n                                Image(systemName: \"highlighter\")\n                            }\n                            Button(action: { viewModel.addBookmark() }) {\n                                Image(systemName: \"bookmark\")\n                            }\n                            Button(action: { viewModel.showScriptureTagging() }) {\n                                Image(systemName: \"book\")\n                            }\n                            Spacer()\n                        }\n                    }\n                \n                // Floating Action Buttons\n                VStack(spacing: 12) {\n                    FloatingActionButton(icon: \"highlighter\") {\n                        viewModel.addHighlight()\n                    }\n                    FloatingActionButton(icon: \"bookmark\") {\n                        viewModel.addBookmark()\n                    }\n                    FloatingActionButton(icon: \"book\") {\n                        viewModel.showScriptureTagging()\n                    }\n                }\n                .padding()                \n            }\n        }\n        .onAppear {\n            viewModel.loadExistingNotes(for: recordingManager.currentRecording)\n        }\n        .sheet(isPresented: $viewModel.showingScriptureSheet) {\n            ScriptureTaggingView(onSave: { reference in\n                viewModel.addScriptureReference(reference)\n            })\n        }\n    }\n}\n\nstruct FloatingActionButton: View {\n    let icon: String\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            Image(systemName: icon)\n                .foregroundColor(.white)\n                .padding(12)\n                .background(Circle().fill(Color.blue))\n                .shadow(radius: 2)\n        }\n    }\n}\n\nstruct Note: Identifiable, Codable {\n    var id = UUID()\n    var content: String\n    var sermonId: UUID\n    var timestamps: [NoteTimestamp] = []\n    var highlights: [TextHighlight] = []\n    var bookmarks: [Bookmark] = []\n    var scriptureReferences: [ScriptureReference] = []\n}\n\nstruct NoteTimestamp: Identifiable, Codable {\n    var id = UUID()\n    var time: TimeInterval\n    var text: String\n}\n\nstruct TextHighlight: Identifiable, Codable {\n    var id = UUID()\n    var range: Range<String.Index>\n    var color: String\n    var timestamp: TimeInterval\n}\n\nstruct Bookmark: Identifiable, Codable {\n    var id = UUID()\n    var timestamp: TimeInterval\n    var label: String\n}\n\nstruct ScriptureReference: Identifiable, Codable {\n    var id = UUID()\n    var book: String\n    var chapter: Int\n    var verse: String\n    var timestamp: TimeInterval\n}\n\nclass NotesViewModel: ObservableObject {\n    @Published var noteText = \"\"\n    @Published var elapsedTime: TimeInterval = 0\n    @Published var showingScriptureSheet = false\n    private var timer: Timer?\n    private var currentRecording: SermonRecording?\n    private var modelContext: ModelContext\n    private var lastTypingTimestamp: Date?\n    private var typingPauseTimer: Timer?\n    \n    init(modelContext: ModelContext) {\n        self.modelContext = modelContext\n        startTimer()\n    }\n    \n    func startTimer() {\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            self?.elapsedTime += 1.0\n        }\n    }\n    \n    func loadExistingNotes(for recording: SermonRecording?) {\n        guard let recording = recording else { return }\n        self.currentRecording = recording\n        \n        if let existingNote = recording.notes?.first {\n            self.noteText = existingNote.content\n        }\n    }\n    \n    func checkForTimestamp(newText: String) {\n        // Check if Enter was pressed\n        if newText.contains(\"\\n\") && !noteText.contains(\"\\n\") {\n            addTimestamp()\n        }\n        \n        // Set up pause detection\n        lastTypingTimestamp = Date()\n        typingPauseTimer?.invalidate()\n        typingPauseTimer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: false) { [weak self] _ in\n            self?.addTimestamp()\n        }\n    }\n    \n    func addTimestamp() {\n        guard let recording = currentRecording else { return }\n        \n        let timestamp = NoteTimestamp(time: elapsedTime, text: noteText)\n        \n        if var note = recording.notes?.first as? Note {\n            note.timestamps.append(timestamp)\n        }\n        \n        try? self.modelContext.save()\n    }\n    \n    func addHighlight() {\n        // Implementation for highlighting selected text\n        // and saving the timestamp\n    }\n    \n    func addBookmark() {\n        guard let recording = currentRecording else { return }\n        \n        let bookmark = Bookmark(timestamp: elapsedTime, label: \"Bookmark at \\(formatTime(elapsedTime))\")\n        \n        if var note = recording.notes?.first as? Note {\n            note.bookmarks.append(bookmark)\n            try? self.modelContext.save()\n        }\n    }\n    \n    func showScriptureTagging() {\n        showingScriptureSheet = true\n    }\n    \n    func addScriptureReference(_ reference: ScriptureReference) {\n        guard let recording = currentRecording else { return }\n        \n        var scriptureRef = reference\n        scriptureRef.timestamp = elapsedTime\n        \n        if var note = recording.notes?.first as? Note {\n            note.scriptureReferences.append(scriptureRef)\n            try? self.modelContext.save()\n        }\n    }\n    \n    func saveNote() {\n        guard let recording = currentRecording else { return }\n        \n        // Debounce save operation\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in\n            guard let self = self else { return }\n            \n            if let existingNote = recording.notes?.first as? Note {\n                existingNote.content = self.noteText\n            } else {\n                let newNote = Note(content: self.noteText, sermonId: recording.id)\n                recording.notes = [newNote]\n            }\n            \n            try? self.modelContext.save()\n        }\n    }\n    \n    private func formatTime(_ timeInterval: TimeInterval) -> String {\n        let minutes = Int(timeInterval) / 60\n        let seconds = Int(timeInterval) % 60\n        return String(format: \"%02d:%02d\", minutes, seconds)\n    }\n}\n```",
      "testStrategy": "1. Test auto-save functionality with timed intervals\n2. Verify note persistence across app restarts\n3. Test keyboard handling and text formatting\n4. Verify dual-pane UI adapts to different device sizes\n5. Test performance with large notes (10,000+ characters)\n6. Verify offline note-taking works correctly\n7. Test note association with the correct recording\n8. Verify UI responsiveness during continuous typing\n9. Test timestamping functionality when Enter is pressed and after typing pauses\n10. Verify highlighting functionality preserves correct timestamps\n11. Test bookmark creation and retrieval\n12. Verify scripture tagging works correctly and saves with timestamps\n13. Test floating action buttons for accessibility and ease of use\n14. Verify audio recording continues uninterrupted during note-taking\n15. Test the complete user journey from recording start to note-taking\n16. Verify the data structure correctly stores all note components (timestamps, highlights, bookmarks, scripture references)",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Integrate AssemblyAI for Transcription and Summarization",
      "description": "Implement the AI transcription and summarization features using AssemblyAI's asynchronous API, with different summary depths based on user tier.",
      "details": "1. Create AssemblyAIService class to handle API interactions\n2. Implement audio upload functionality to AssemblyAI\n3. Create polling mechanism for asynchronous transcription status\n4. Implement summary generation with tier-based depth:\n   - Free tier: High-level summary\n   - Paid tier: Deep summary + insights + preaching tone\n5. Store and display transcription and summary results\n6. Implement error handling and retry logic\n7. Add offline queueing for uploads when internet becomes available\n\nCode example for AssemblyAIService:\n```swift\nclass AssemblyAIService {\n    private let apiKey = \"YOUR_ASSEMBLY_AI_KEY\" // Store securely\n    private let baseURL = \"https://api.assemblyai.com/v2\"\n    \n    func uploadAudio(fileURL: URL) async throws -> String {\n        let uploadURL = URL(string: \"\\(baseURL)/upload\")\n        \n        var request = URLRequest(url: uploadURL!)\n        request.httpMethod = \"POST\"\n        request.setValue(apiKey, forHTTPHeaderField: \"authorization\")\n        \n        let data = try Data(contentsOf: fileURL)\n        \n        let (responseData, response) = try await URLSession.shared.upload(for: request, from: data)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"AssemblyAIError\", code: 1, userInfo: [NSLocalizedDescriptionKey: \"Upload failed\"])\n        }\n        \n        let uploadResponse = try JSONDecoder().decode(UploadResponse.self, from: responseData)\n        return uploadResponse.uploadUrl\n    }\n    \n    func transcribeAudio(audioURL: String, isPaidUser: Bool) async throws -> String {\n        let transcriptionURL = URL(string: \"\\(baseURL)/transcript\")\n        \n        var request = URLRequest(url: transcriptionURL!)\n        request.httpMethod = \"POST\"\n        request.setValue(apiKey, forHTTPHeaderField: \"authorization\")\n        request.setValue(\"application/json\", forHTTPHeaderField: \"content-type\")\n        \n        // Configure different summarization based on user tier\n        let summaryType = isPaidUser ? \"detailed\" : \"headline\"\n        \n        let requestBody: [String: Any] = [\n            \"audio_url\": audioURL,\n            \"auto_chapters\": true,\n            \"summarization\": true,\n            \"summary_type\": summaryType,\n            \"summary_model\": \"conversational\"\n        ]\n        \n        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)\n        \n        let (responseData, response) = try await URLSession.shared.data(for: request)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"AssemblyAIError\", code: 2, userInfo: [NSLocalizedDescriptionKey: \"Transcription request failed\"])\n        }\n        \n        let transcriptionResponse = try JSONDecoder().decode(TranscriptionResponse.self, from: responseData)\n        return transcriptionResponse.id\n    }\n    \n    func getTranscriptionResult(id: String) async throws -> TranscriptionResult {\n        let resultURL = URL(string: \"\\(baseURL)/transcript/\\(id)\")\n        \n        var request = URLRequest(url: resultURL!)\n        request.setValue(apiKey, forHTTPHeaderField: \"authorization\")\n        \n        let (data, response) = try await URLSession.shared.data(for: request)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"AssemblyAIError\", code: 3, userInfo: [NSLocalizedDescriptionKey: \"Failed to get transcription\"])\n        }\n        \n        return try JSONDecoder().decode(TranscriptionResult.self, from: data)\n    }\n    \n    func pollForTranscriptionCompletion(id: String) async throws -> TranscriptionResult {\n        var result = try await getTranscriptionResult(id: id)\n        \n        while result.status != \"completed\" && result.status != \"error\" {\n            try await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds\n            result = try await getTranscriptionResult(id: id)\n        }\n        \n        if result.status == \"error\" {\n            throw NSError(domain: \"AssemblyAIError\", code: 4, userInfo: [NSLocalizedDescriptionKey: result.error ?? \"Unknown error\"])\n        }\n        \n        return result\n    }\n}\n\nstruct UploadResponse: Decodable {\n    let uploadUrl: String\n}\n\nstruct TranscriptionResponse: Decodable {\n    let id: String\n}\n\nstruct TranscriptionResult: Decodable {\n    let id: String\n    let status: String\n    let text: String?\n    let summary: String?\n    let chapters: [Chapter]?\n    let error: String?\n}\n\nstruct Chapter: Decodable {\n    let headline: String\n    let summary: String\n    let start: Int\n    let end: Int\n}\n```",
      "testStrategy": "1. Test API integration with mock responses\n2. Verify different summary depths based on user tier\n3. Test polling mechanism with various response scenarios\n4. Verify error handling and retry logic\n5. Test offline queueing and subsequent upload\n6. Measure performance with large audio files\n7. Test transcription accuracy with various sermon styles\n8. Verify proper storage and display of transcription results",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement Scripture Detection and Bible Reference API Integration",
      "description": "Create the scripture detection system that identifies Bible references in transcriptions and integrates with the Bible Reference API to provide contextual information and related passages.",
      "details": "1. Create BibleReferenceService to interact with Bible Reference API\n2. Implement regex patterns to detect common Bible verse formats in transcriptions\n3. Create UI components to display scripture references with contextual information\n4. Implement tappable verse references that expand to show full context\n5. Add related passages functionality for paid tier users\n6. Cache scripture data for offline access\n7. Implement error handling for API failures\n\nCode example for Scripture Detection and Reference Service:\n```swift\nclass BibleReferenceService {\n    private let apiBaseURL = \"https://bible-api.com\" // Example API\n    \n    // Regex patterns for common Bible verse formats\n    private let versePatterns = [\n        \"(Genesis|Exodus|Leviticus|Numbers|Deuteronomy|Joshua|Judges|Ruth|1 Samuel|2 Samuel|1 Kings|2 Kings|1 Chronicles|2 Chronicles|Ezra|Nehemiah|Esther|Job|Psalm|Psalms|Proverbs|Ecclesiastes|Song of Solomon|Isaiah|Jeremiah|Lamentations|Ezekiel|Daniel|Hosea|Joel|Amos|Obadiah|Jonah|Micah|Nahum|Habakkuk|Zephaniah|Haggai|Zechariah|Malachi|Matthew|Mark|Luke|John|Acts|Romans|1 Corinthians|2 Corinthians|Galatians|Ephesians|Philippians|Colossians|1 Thessalonians|2 Thessalonians|1 Timothy|2 Timothy|Titus|Philemon|Hebrews|James|1 Peter|2 Peter|1 John|2 John|3 John|Jude|Revelation)\\s+(\\d+):(\\d+)(?:-(\\d+))?\"\nn    ]\n    \n    func detectScriptureReferences(in text: String) -> [ScriptureReference] {\n        var references = [ScriptureReference]()\n        \n        for pattern in versePatterns {\n            let regex = try? NSRegularExpression(pattern: pattern)\n            let nsString = text as NSString\n            let matches = regex?.matches(in: text, range: NSRange(location: 0, length: nsString.length)) ?? []\n            \n            for match in matches {\n                let book = nsString.substring(with: match.range(at: 1))\n                let chapter = nsString.substring(with: match.range(at: 2))\n                let verseStart = nsString.substring(with: match.range(at: 3))\n                let verseEnd = match.range(at: 4).location != NSNotFound ? nsString.substring(with: match.range(at: 4)) : nil\n                \n                let reference = ScriptureReference(\n                    book: book,\n                    chapter: Int(chapter) ?? 0,\n                    verseStart: Int(verseStart) ?? 0,\n                    verseEnd: verseEnd != nil ? Int(verseEnd!) : nil,\n                    textRange: match.range\n                )\n                \n                references.append(reference)\n            }\n        }\n        \n        return references\n    }\n    \n    func fetchVerseContent(for reference: ScriptureReference) async throws -> ScriptureContent {\n        var urlString = \"\\(apiBaseURL)/\\(reference.book)+\\(reference.chapter):\\(reference.verseStart)\"\n        \n        if let verseEnd = reference.verseEnd {\n            urlString += \"-\\(verseEnd)\"\n        }\n        \n        guard let url = URL(string: urlString) else {\n            throw NSError(domain: \"BibleReferenceError\", code: 1, userInfo: [NSLocalizedDescriptionKey: \"Invalid URL\"])\n        }\n        \n        let (data, response) = try await URLSession.shared.data(from: url)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"BibleReferenceError\", code: 2, userInfo: [NSLocalizedDescriptionKey: \"API request failed\"])\n        }\n        \n        return try JSONDecoder().decode(ScriptureContent.self, from: data)\n    }\n    \n    func fetchRelatedPassages(for reference: ScriptureReference) async throws -> [RelatedPassage] {\n        // This would connect to a more advanced Bible API that provides related passages\n        // For MVP, we could use a simpler approach or pre-defined relationships\n        \n        // Example implementation\n        let urlString = \"\\(apiBaseURL)/related/\\(reference.book)/\\(reference.chapter)/\\(reference.verseStart)\"\n        guard let url = URL(string: urlString) else {\n            throw NSError(domain: \"BibleReferenceError\", code: 3, userInfo: [NSLocalizedDescriptionKey: \"Invalid URL\"])\n        }\n        \n        let (data, response) = try await URLSession.shared.data(from: url)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"BibleReferenceError\", code: 4, userInfo: [NSLocalizedDescriptionKey: \"API request failed\"])\n        }\n        \n        return try JSONDecoder().decode([RelatedPassage].self, from: data)\n    }\n}\n\nstruct ScriptureReference {\n    let book: String\n    let chapter: Int\n    let verseStart: Int\n    let verseEnd: Int?\n    let textRange: NSRange\n    \n    var displayString: String {\n        if let verseEnd = verseEnd {\n            return \"\\(book) \\(chapter):\\(verseStart)-\\(verseEnd)\"\n        } else {\n            return \"\\(book) \\(chapter):\\(verseStart)\"\n        }\n    }\n}\n\nstruct ScriptureContent: Decodable {\n    let reference: String\n    let text: String\n    let translation: String\n    let context: String?\n}\n\nstruct RelatedPassage: Decodable {\n    let reference: String\n    let text: String\n    let relationship: String // e.g., \"parallel\", \"commentary\", \"cross-reference\"\n}\n```",
      "testStrategy": "1. Test scripture detection with various verse formats\n2. Verify Bible Reference API integration with mock responses\n3. Test UI components for displaying scripture references\n4. Verify contextual information display\n5. Test related passages functionality for paid tier users\n6. Verify offline caching of scripture data\n7. Test error handling for API failures\n8. Verify performance with large transcriptions containing many references",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement User Account System and Subscription Management",
      "description": "Create the user authentication system using Supabase, implement user roles (Free/Paid), and integrate Stripe for subscription billing.",
      "details": "1. Set up Supabase project and configure authentication\n2. Implement email/password authentication flow\n3. Create user profile management\n4. Set up Stripe integration for subscription billing\n5. Implement tier-based feature access control\n6. Create settings interface for account management\n7. Implement usage tracking for free tier limitations\n8. Add secure storage for user preferences\n\nCode example for Authentication and Subscription Service:\n```swift\nimport Supabase\nimport Stripe\n\nclass AuthService: ObservableObject {\n    @Published var currentUser: User?\n    @Published var isAuthenticated = false\n    @Published var userTier: UserTier = .free\n    \n    private let supabase = SupabaseClient(\n        supabaseURL: URL(string: \"YOUR_SUPABASE_URL\")!,\n        supabaseKey: \"YOUR_SUPABASE_KEY\"\n    )\n    \n    private let stripePublishableKey = \"YOUR_STRIPE_PUBLISHABLE_KEY\"\n    \n    init() {\n        // Check for existing session\n        Task {\n            do {\n                let session = try await supabase.auth.session\n                await MainActor.run {\n                    self.currentUser = session.user\n                    self.isAuthenticated = true\n                    self.fetchUserTier()\n                }\n            } catch {\n                print(\"No active session: \\(error)\")\n            }\n        }\n    }\n    \n    func signUp(email: String, password: String) async throws {\n        let response = try await supabase.auth.signUp(\n            email: email,\n            password: password\n        )\n        \n        await MainActor.run {\n            self.currentUser = response.user\n            self.isAuthenticated = true\n            self.userTier = .free\n        }\n        \n        // Create user profile in database\n        try await createUserProfile(userId: response.user.id)\n    }\n    \n    func signIn(email: String, password: String) async throws {\n        let response = try await supabase.auth.signIn(\n            email: email,\n            password: password\n        )\n        \n        await MainActor.run {\n            self.currentUser = response.user\n            self.isAuthenticated = true\n            self.fetchUserTier()\n        }\n    }\n    \n    func signOut() async throws {\n        try await supabase.auth.signOut()\n        \n        await MainActor.run {\n            self.currentUser = nil\n            self.isAuthenticated = false\n            self.userTier = .free\n        }\n    }\n    \n    private func createUserProfile(userId: String) async throws {\n        let profile = UserProfile(\n            id: userId,\n            email: currentUser?.email ?? \"\",\n            tier: \"free\",\n            createdAt: Date()\n        )\n        \n        try await supabase\n            .from(\"profiles\")\n            .insert(profile)\n            .execute()\n    }\n    \n    private func fetchUserTier() {\n        guard let userId = currentUser?.id else { return }\n        \n        Task {\n            do {\n                let response = try await supabase\n                    .from(\"profiles\")\n                    .select()\n                    .eq(\"id\", value: userId)\n                    .single()\n                    .execute()\n                \n                if let profile = try response.decoded(as: UserProfile.self) {\n                    await MainActor.run {\n                        self.userTier = profile.tier == \"paid\" ? .paid : .free\n                    }\n                }\n            } catch {\n                print(\"Error fetching user tier: \\(error)\")\n            }\n        }\n    }\n    \n    func upgradeToProTier() async throws {\n        // Initialize Stripe payment sheet\n        let backendURL = URL(string: \"YOUR_BACKEND_URL/create-payment-intent\")!\n        var request = URLRequest(url: backendURL)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        \n        let (data, _) = try await URLSession.shared.data(for: request)\n        let paymentIntentResponse = try JSONDecoder().decode(PaymentIntentResponse.self, from: data)\n        \n        // Configure Stripe payment sheet\n        STPAPIClient.shared.publishableKey = stripePublishableKey\n        let paymentSheet = PaymentSheet(paymentIntentClientSecret: paymentIntentResponse.clientSecret)\n        \n        // Present payment sheet (this would be called from UI)\n        // After successful payment, update user tier in database\n        if let userId = currentUser?.id {\n            try await supabase\n                .from(\"profiles\")\n                .update([\"tier\": \"paid\"])\n                .eq(\"id\", value: userId)\n                .execute()\n            \n            await MainActor.run {\n                self.userTier = .paid\n            }\n        }\n    }\n}\n\nenum UserTier {\n    case free\n    case paid\n}\n\nstruct UserProfile: Codable {\n    let id: String\n    let email: String\n    let tier: String\n    let createdAt: Date\n}\n\nstruct PaymentIntentResponse: Decodable {\n    let clientSecret: String\n}\n```",
      "testStrategy": "1. Test user registration flow\n2. Verify login and session management\n3. Test Stripe integration with test cards\n4. Verify tier-based feature access control\n5. Test user profile management\n6. Verify secure storage of user preferences\n7. Test usage tracking for free tier limitations\n8. Verify error handling for authentication failures\n9. Test subscription upgrade and downgrade flows",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    }
  ]
}