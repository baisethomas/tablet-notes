{
  "tasks": [
    {
      "id": 1,
      "title": "Setup iOS Project with SwiftUI and Core Architecture",
      "description": "Initialize the iOS project with SwiftUI, implement MVVM architecture, and set up the basic project structure including data models and local storage with SwiftData.",
      "details": "1. Create a new iOS project using SwiftUI\n2. Set up MVVM architecture with folders for Models, Views, ViewModels\n3. Implement core data models:\n   - SermonRecording (id, title, audioURL, serviceType, date, duration)\n   - Note (id, content, timestamp, sermonId)\n   - Transcription (id, content, sermonId)\n   - UserProfile (id, email, tier, usage)\n   - ServiceType (enum: Sunday, BibleStudy, Midweek, Conference, GuestSpeaker)\n4. Configure SwiftData for local storage\n5. Set up basic navigation structure with TabView\n6. Implement offline-first approach with local caching\n7. Create reusable UI components\n\nCode example for SermonRecording model:\n```swift\n@Model\nclass SermonRecording {\n    var id: UUID\n    var title: String\n    var audioURL: URL?\n    var serviceType: ServiceType\n    var date: Date\n    var duration: TimeInterval\n    var notes: [Note]?\n    var transcription: Transcription?\n    \n    init(id: UUID = UUID(), title: String, serviceType: ServiceType, date: Date = Date()) {\n        self.id = id\n        self.title = title\n        self.serviceType = serviceType\n        self.date = date\n        self.duration = 0\n    }\n}\n```",
      "testStrategy": "1. Unit tests for all data models to ensure proper initialization and relationships\n2. UI tests for basic navigation flow\n3. Test offline capabilities by toggling network connection\n4. Verify SwiftData persistence by creating and retrieving objects\n5. Test app performance metrics including launch time (target: under 2 seconds)\n6. Verify proper MVVM separation by testing ViewModels independently",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Audio Recording and Service Type Selection",
      "description": "Create the audio recording functionality with AVFoundation, implement the record button UI, service type selection modal, and recording status indicators.",
      "details": "1. Implement AVFoundation integration for audio recording\n2. Configure audio settings: AAC format, 128kbps, 44.1kHz\n3. Create RecordingManager class to handle recording state and file management\n4. Design and implement the central record button in tab bar\n5. Create service type selection modal that appears after tapping record\n6. Implement visual recording indicators (animated waveform or timer)\n7. Handle permissions for microphone access\n8. Implement offline recording capability with local storage\n9. Add higher quality recording option (256kbps) for paid tier users\n\nCode example for RecordingManager:\n```swift\nclass RecordingManager: ObservableObject {\n    @Published var isRecording = false\n    @Published var currentRecording: SermonRecording?\n    private var audioRecorder: AVAudioRecorder?\n    \n    func startRecording(serviceType: ServiceType) {\n        let audioSession = AVAudioSession.sharedInstance()\n        \n        do {\n            try audioSession.setCategory(.playAndRecord, mode: .default)\n            try audioSession.setActive(true)\n            \n            let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n            let audioFilename = documentsPath.appendingPathComponent(\"\\(UUID().uuidString).m4a\")\n            \n            let settings = [\n                AVFormatIDKey: Int(kAudioFormatMPEG4AAC),\n                AVSampleRateKey: 44100.0,\n                AVNumberOfChannelsKey: 1,\n                AVEncoderBitRateKey: 128000\n            ] as [String: Any]\n            \n            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)\n            audioRecorder?.record()\n            \n            isRecording = true\n            currentRecording = SermonRecording(title: \"New Recording\", serviceType: serviceType)\n            currentRecording?.audioURL = audioFilename\n        } catch {\n            print(\"Recording failed: \\(error)\")\n        }\n    }\n    \n    func stopRecording() {\n        audioRecorder?.stop()\n        isRecording = false\n        // Save recording to SwiftData\n    }\n}\n```",
      "testStrategy": "1. Test microphone permission handling\n2. Verify audio recording quality and format\n3. Test service type selection modal UI and functionality\n4. Verify recording indicators update correctly\n5. Test offline recording and subsequent upload\n6. Measure battery impact during extended recording sessions\n7. Verify different quality settings for free vs paid users\n8. Test error handling for recording failures",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Develop Real-time Note-taking Interface",
      "description": "Create the split-screen note-taking interface that allows users to type notes while recording is in progress, with continuous auto-save functionality.",
      "details": "1. Design split-screen UI with recording status at top and note-taking area below\n2. Implement TextEditor with styling for note input\n3. Create auto-save functionality that persists notes as user types\n4. Implement note association with current recording session\n5. Add keyboard handling and text formatting options\n6. Create NotesViewModel to manage note state and persistence\n7. Implement offline support for notes\n\nCode example for NotesView:\n```swift\nstruct NotesView: View {\n    @ObservedObject var viewModel: NotesViewModel\n    @EnvironmentObject var recordingManager: RecordingManager\n    \n    var body: some View {\n        VStack(spacing: 0) {\n            // Recording status header\n            if recordingManager.isRecording {\n                RecordingStatusView(duration: viewModel.elapsedTime)\n                    .frame(height: 60)\n                    .background(Color.red.opacity(0.1))\n            }\n            \n            // Note taking area\n            TextEditor(text: $viewModel.noteText)\n                .padding()\n                .onChange(of: viewModel.noteText) { newValue in\n                    viewModel.saveNote()\n                }\n                .toolbar {\n                    ToolbarItemGroup(placement: .keyboard) {\n                        // Text formatting buttons\n                        Button(action: { viewModel.formatBold() }) {\n                            Image(systemName: \"bold\")\n                        }\n                        Button(action: { viewModel.formatItalic() }) {\n                            Image(systemName: \"italic\")\n                        }\n                        Spacer()\n                    }\n                }\n        }\n        .onAppear {\n            viewModel.loadExistingNotes(for: recordingManager.currentRecording)\n        }\n    }\n}\n\nclass NotesViewModel: ObservableObject {\n    @Published var noteText = \"\"\n    @Published var elapsedTime: TimeInterval = 0\n    private var timer: Timer?\n    private var currentRecording: SermonRecording?\n    private var modelContext: ModelContext\n    \n    init(modelContext: ModelContext) {\n        self.modelContext = modelContext\n        startTimer()\n    }\n    \n    func startTimer() {\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            self?.elapsedTime += 1.0\n        }\n    }\n    \n    func loadExistingNotes(for recording: SermonRecording?) {\n        guard let recording = recording else { return }\n        self.currentRecording = recording\n        \n        if let existingNote = recording.notes?.first {\n            self.noteText = existingNote.content\n        }\n    }\n    \n    func saveNote() {\n        guard let recording = currentRecording else { return }\n        \n        // Debounce save operation\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in\n            guard let self = self else { return }\n            \n            if let existingNote = recording.notes?.first {\n                existingNote.content = self.noteText\n            } else {\n                let newNote = Note(content: self.noteText, sermonId: recording.id)\n                recording.notes = [newNote]\n            }\n            \n            try? self.modelContext.save()\n        }\n    }\n}\n```",
      "testStrategy": "1. Test auto-save functionality with timed intervals\n2. Verify note persistence across app restarts\n3. Test keyboard handling and text formatting\n4. Verify split-screen UI adapts to different device sizes\n5. Test performance with large notes (10,000+ characters)\n6. Verify offline note-taking works correctly\n7. Test note association with the correct recording\n8. Verify UI responsiveness during continuous typing",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Integrate AssemblyAI for Transcription and Summarization",
      "description": "Implement the AI transcription and summarization features using AssemblyAI's asynchronous API, with different summary depths based on user tier.",
      "details": "1. Create AssemblyAIService class to handle API interactions\n2. Implement audio upload functionality to AssemblyAI\n3. Create polling mechanism for asynchronous transcription status\n4. Implement summary generation with tier-based depth:\n   - Free tier: High-level summary\n   - Paid tier: Deep summary + insights + preaching tone\n5. Store and display transcription and summary results\n6. Implement error handling and retry logic\n7. Add offline queueing for uploads when internet becomes available\n\nCode example for AssemblyAIService:\n```swift\nclass AssemblyAIService {\n    private let apiKey = \"YOUR_ASSEMBLY_AI_KEY\" // Store securely\n    private let baseURL = \"https://api.assemblyai.com/v2\"\n    \n    func uploadAudio(fileURL: URL) async throws -> String {\n        let uploadURL = URL(string: \"\\(baseURL)/upload\")\n        \n        var request = URLRequest(url: uploadURL!)\n        request.httpMethod = \"POST\"\n        request.setValue(apiKey, forHTTPHeaderField: \"authorization\")\n        \n        let data = try Data(contentsOf: fileURL)\n        \n        let (responseData, response) = try await URLSession.shared.upload(for: request, from: data)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"AssemblyAIError\", code: 1, userInfo: [NSLocalizedDescriptionKey: \"Upload failed\"])\n        }\n        \n        let uploadResponse = try JSONDecoder().decode(UploadResponse.self, from: responseData)\n        return uploadResponse.uploadUrl\n    }\n    \n    func transcribeAudio(audioURL: String, isPaidUser: Bool) async throws -> String {\n        let transcriptionURL = URL(string: \"\\(baseURL)/transcript\")\n        \n        var request = URLRequest(url: transcriptionURL!)\n        request.httpMethod = \"POST\"\n        request.setValue(apiKey, forHTTPHeaderField: \"authorization\")\n        request.setValue(\"application/json\", forHTTPHeaderField: \"content-type\")\n        \n        // Configure different summarization based on user tier\n        let summaryType = isPaidUser ? \"detailed\" : \"headline\"\n        \n        let requestBody: [String: Any] = [\n            \"audio_url\": audioURL,\n            \"auto_chapters\": true,\n            \"summarization\": true,\n            \"summary_type\": summaryType,\n            \"summary_model\": \"conversational\"\n        ]\n        \n        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)\n        \n        let (responseData, response) = try await URLSession.shared.data(for: request)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"AssemblyAIError\", code: 2, userInfo: [NSLocalizedDescriptionKey: \"Transcription request failed\"])\n        }\n        \n        let transcriptionResponse = try JSONDecoder().decode(TranscriptionResponse.self, from: responseData)\n        return transcriptionResponse.id\n    }\n    \n    func getTranscriptionResult(id: String) async throws -> TranscriptionResult {\n        let resultURL = URL(string: \"\\(baseURL)/transcript/\\(id)\")\n        \n        var request = URLRequest(url: resultURL!)\n        request.setValue(apiKey, forHTTPHeaderField: \"authorization\")\n        \n        let (data, response) = try await URLSession.shared.data(for: request)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"AssemblyAIError\", code: 3, userInfo: [NSLocalizedDescriptionKey: \"Failed to get transcription\"])\n        }\n        \n        return try JSONDecoder().decode(TranscriptionResult.self, from: data)\n    }\n    \n    func pollForTranscriptionCompletion(id: String) async throws -> TranscriptionResult {\n        var result = try await getTranscriptionResult(id: id)\n        \n        while result.status != \"completed\" && result.status != \"error\" {\n            try await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds\n            result = try await getTranscriptionResult(id: id)\n        }\n        \n        if result.status == \"error\" {\n            throw NSError(domain: \"AssemblyAIError\", code: 4, userInfo: [NSLocalizedDescriptionKey: result.error ?? \"Unknown error\"])\n        }\n        \n        return result\n    }\n}\n\nstruct UploadResponse: Decodable {\n    let uploadUrl: String\n}\n\nstruct TranscriptionResponse: Decodable {\n    let id: String\n}\n\nstruct TranscriptionResult: Decodable {\n    let id: String\n    let status: String\n    let text: String?\n    let summary: String?\n    let chapters: [Chapter]?\n    let error: String?\n}\n\nstruct Chapter: Decodable {\n    let headline: String\n    let summary: String\n    let start: Int\n    let end: Int\n}\n```",
      "testStrategy": "1. Test API integration with mock responses\n2. Verify different summary depths based on user tier\n3. Test polling mechanism with various response scenarios\n4. Verify error handling and retry logic\n5. Test offline queueing and subsequent upload\n6. Measure performance with large audio files\n7. Test transcription accuracy with various sermon styles\n8. Verify proper storage and display of transcription results",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement Scripture Detection and Bible Reference API Integration",
      "description": "Create the scripture detection system that identifies Bible references in transcriptions and integrates with the Bible Reference API to provide contextual information and related passages.",
      "details": "1. Create BibleReferenceService to interact with Bible Reference API\n2. Implement regex patterns to detect common Bible verse formats in transcriptions\n3. Create UI components to display scripture references with contextual information\n4. Implement tappable verse references that expand to show full context\n5. Add related passages functionality for paid tier users\n6. Cache scripture data for offline access\n7. Implement error handling for API failures\n\nCode example for Scripture Detection and Reference Service:\n```swift\nclass BibleReferenceService {\n    private let apiBaseURL = \"https://bible-api.com\" // Example API\n    \n    // Regex patterns for common Bible verse formats\n    private let versePatterns = [\n        \"(Genesis|Exodus|Leviticus|Numbers|Deuteronomy|Joshua|Judges|Ruth|1 Samuel|2 Samuel|1 Kings|2 Kings|1 Chronicles|2 Chronicles|Ezra|Nehemiah|Esther|Job|Psalm|Psalms|Proverbs|Ecclesiastes|Song of Solomon|Isaiah|Jeremiah|Lamentations|Ezekiel|Daniel|Hosea|Joel|Amos|Obadiah|Jonah|Micah|Nahum|Habakkuk|Zephaniah|Haggai|Zechariah|Malachi|Matthew|Mark|Luke|John|Acts|Romans|1 Corinthians|2 Corinthians|Galatians|Ephesians|Philippians|Colossians|1 Thessalonians|2 Thessalonians|1 Timothy|2 Timothy|Titus|Philemon|Hebrews|James|1 Peter|2 Peter|1 John|2 John|3 John|Jude|Revelation)\\s+(\\d+):(\\d+)(?:-(\\d+))?\"\nn    ]\n    \n    func detectScriptureReferences(in text: String) -> [ScriptureReference] {\n        var references = [ScriptureReference]()\n        \n        for pattern in versePatterns {\n            let regex = try? NSRegularExpression(pattern: pattern)\n            let nsString = text as NSString\n            let matches = regex?.matches(in: text, range: NSRange(location: 0, length: nsString.length)) ?? []\n            \n            for match in matches {\n                let book = nsString.substring(with: match.range(at: 1))\n                let chapter = nsString.substring(with: match.range(at: 2))\n                let verseStart = nsString.substring(with: match.range(at: 3))\n                let verseEnd = match.range(at: 4).location != NSNotFound ? nsString.substring(with: match.range(at: 4)) : nil\n                \n                let reference = ScriptureReference(\n                    book: book,\n                    chapter: Int(chapter) ?? 0,\n                    verseStart: Int(verseStart) ?? 0,\n                    verseEnd: verseEnd != nil ? Int(verseEnd!) : nil,\n                    textRange: match.range\n                )\n                \n                references.append(reference)\n            }\n        }\n        \n        return references\n    }\n    \n    func fetchVerseContent(for reference: ScriptureReference) async throws -> ScriptureContent {\n        var urlString = \"\\(apiBaseURL)/\\(reference.book)+\\(reference.chapter):\\(reference.verseStart)\"\n        \n        if let verseEnd = reference.verseEnd {\n            urlString += \"-\\(verseEnd)\"\n        }\n        \n        guard let url = URL(string: urlString) else {\n            throw NSError(domain: \"BibleReferenceError\", code: 1, userInfo: [NSLocalizedDescriptionKey: \"Invalid URL\"])\n        }\n        \n        let (data, response) = try await URLSession.shared.data(from: url)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"BibleReferenceError\", code: 2, userInfo: [NSLocalizedDescriptionKey: \"API request failed\"])\n        }\n        \n        return try JSONDecoder().decode(ScriptureContent.self, from: data)\n    }\n    \n    func fetchRelatedPassages(for reference: ScriptureReference) async throws -> [RelatedPassage] {\n        // This would connect to a more advanced Bible API that provides related passages\n        // For MVP, we could use a simpler approach or pre-defined relationships\n        \n        // Example implementation\n        let urlString = \"\\(apiBaseURL)/related/\\(reference.book)/\\(reference.chapter)/\\(reference.verseStart)\"\n        guard let url = URL(string: urlString) else {\n            throw NSError(domain: \"BibleReferenceError\", code: 3, userInfo: [NSLocalizedDescriptionKey: \"Invalid URL\"])\n        }\n        \n        let (data, response) = try await URLSession.shared.data(from: url)\n        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {\n            throw NSError(domain: \"BibleReferenceError\", code: 4, userInfo: [NSLocalizedDescriptionKey: \"API request failed\"])\n        }\n        \n        return try JSONDecoder().decode([RelatedPassage].self, from: data)\n    }\n}\n\nstruct ScriptureReference {\n    let book: String\n    let chapter: Int\n    let verseStart: Int\n    let verseEnd: Int?\n    let textRange: NSRange\n    \n    var displayString: String {\n        if let verseEnd = verseEnd {\n            return \"\\(book) \\(chapter):\\(verseStart)-\\(verseEnd)\"\n        } else {\n            return \"\\(book) \\(chapter):\\(verseStart)\"\n        }\n    }\n}\n\nstruct ScriptureContent: Decodable {\n    let reference: String\n    let text: String\n    let translation: String\n    let context: String?\n}\n\nstruct RelatedPassage: Decodable {\n    let reference: String\n    let text: String\n    let relationship: String // e.g., \"parallel\", \"commentary\", \"cross-reference\"\n}\n```",
      "testStrategy": "1. Test scripture detection with various verse formats\n2. Verify Bible Reference API integration with mock responses\n3. Test UI components for displaying scripture references\n4. Verify contextual information display\n5. Test related passages functionality for paid tier users\n6. Verify offline caching of scripture data\n7. Test error handling for API failures\n8. Verify performance with large transcriptions containing many references",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement User Account System and Subscription Management",
      "description": "Create the user authentication system using Supabase, implement user roles (Free/Paid), and integrate Stripe for subscription billing.",
      "details": "1. Set up Supabase project and configure authentication\n2. Implement email/password authentication flow\n3. Create user profile management\n4. Set up Stripe integration for subscription billing\n5. Implement tier-based feature access control\n6. Create settings interface for account management\n7. Implement usage tracking for free tier limitations\n8. Add secure storage for user preferences\n\nCode example for Authentication and Subscription Service:\n```swift\nimport Supabase\nimport Stripe\n\nclass AuthService: ObservableObject {\n    @Published var currentUser: User?\n    @Published var isAuthenticated = false\n    @Published var userTier: UserTier = .free\n    \n    private let supabase = SupabaseClient(\n        supabaseURL: URL(string: \"YOUR_SUPABASE_URL\")!,\n        supabaseKey: \"YOUR_SUPABASE_KEY\"\n    )\n    \n    private let stripePublishableKey = \"YOUR_STRIPE_PUBLISHABLE_KEY\"\n    \n    init() {\n        // Check for existing session\n        Task {\n            do {\n                let session = try await supabase.auth.session\n                await MainActor.run {\n                    self.currentUser = session.user\n                    self.isAuthenticated = true\n                    self.fetchUserTier()\n                }\n            } catch {\n                print(\"No active session: \\(error)\")\n            }\n        }\n    }\n    \n    func signUp(email: String, password: String) async throws {\n        let response = try await supabase.auth.signUp(\n            email: email,\n            password: password\n        )\n        \n        await MainActor.run {\n            self.currentUser = response.user\n            self.isAuthenticated = true\n            self.userTier = .free\n        }\n        \n        // Create user profile in database\n        try await createUserProfile(userId: response.user.id)\n    }\n    \n    func signIn(email: String, password: String) async throws {\n        let response = try await supabase.auth.signIn(\n            email: email,\n            password: password\n        )\n        \n        await MainActor.run {\n            self.currentUser = response.user\n            self.isAuthenticated = true\n            self.fetchUserTier()\n        }\n    }\n    \n    func signOut() async throws {\n        try await supabase.auth.signOut()\n        \n        await MainActor.run {\n            self.currentUser = nil\n            self.isAuthenticated = false\n            self.userTier = .free\n        }\n    }\n    \n    private func createUserProfile(userId: String) async throws {\n        let profile = UserProfile(\n            id: userId,\n            email: currentUser?.email ?? \"\",\n            tier: \"free\",\n            createdAt: Date()\n        )\n        \n        try await supabase\n            .from(\"profiles\")\n            .insert(profile)\n            .execute()\n    }\n    \n    private func fetchUserTier() {\n        guard let userId = currentUser?.id else { return }\n        \n        Task {\n            do {\n                let response = try await supabase\n                    .from(\"profiles\")\n                    .select()\n                    .eq(\"id\", value: userId)\n                    .single()\n                    .execute()\n                \n                if let profile = try response.decoded(as: UserProfile.self) {\n                    await MainActor.run {\n                        self.userTier = profile.tier == \"paid\" ? .paid : .free\n                    }\n                }\n            } catch {\n                print(\"Error fetching user tier: \\(error)\")\n            }\n        }\n    }\n    \n    func upgradeToProTier() async throws {\n        // Initialize Stripe payment sheet\n        let backendURL = URL(string: \"YOUR_BACKEND_URL/create-payment-intent\")!\n        var request = URLRequest(url: backendURL)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        \n        let (data, _) = try await URLSession.shared.data(for: request)\n        let paymentIntentResponse = try JSONDecoder().decode(PaymentIntentResponse.self, from: data)\n        \n        // Configure Stripe payment sheet\n        STPAPIClient.shared.publishableKey = stripePublishableKey\n        let paymentSheet = PaymentSheet(paymentIntentClientSecret: paymentIntentResponse.clientSecret)\n        \n        // Present payment sheet (this would be called from UI)\n        // After successful payment, update user tier in database\n        if let userId = currentUser?.id {\n            try await supabase\n                .from(\"profiles\")\n                .update([\"tier\": \"paid\"])\n                .eq(\"id\", value: userId)\n                .execute()\n            \n            await MainActor.run {\n                self.userTier = .paid\n            }\n        }\n    }\n}\n\nenum UserTier {\n    case free\n    case paid\n}\n\nstruct UserProfile: Codable {\n    let id: String\n    let email: String\n    let tier: String\n    let createdAt: Date\n}\n\nstruct PaymentIntentResponse: Decodable {\n    let clientSecret: String\n}\n```",
      "testStrategy": "1. Test user registration flow\n2. Verify login and session management\n3. Test Stripe integration with test cards\n4. Verify tier-based feature access control\n5. Test user profile management\n6. Verify secure storage of user preferences\n7. Test usage tracking for free tier limitations\n8. Verify error handling for authentication failures\n9. Test subscription upgrade and downgrade flows",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    }
  ]
}